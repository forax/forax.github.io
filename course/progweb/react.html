<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>React</title>

		<meta name="description" content="JavaScript">
		<meta name="author" content="Remi Forax">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
		
		<!-- autojs result -->
		<style>
		  div.autojsresult {
		    text-align: left;
		    color: lime;
		  }
		  div.autojslog {
		    color: orange;
		  }
		  div.autojserror {
		    color: red;
		  }
		  .bad-container {
            position: relative;
            display:inline-block;
          }
		  .bad-image:after {
            content: url(images/js/bad.png);
            position: absolute;
            z-index: 9999;
            right: 5px;
            bottom: 0px;
          }
		</style>

    <!-- react imports -->
    <!-- script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script -->

	<script src="images/react/react.development18.3.1.js"></script>
	<script src="images/react/react-dom.development18.3.1.js"></script>
	<script src="images/react/babel7.24.6.min.js"></script>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
                <section>
					<h1>React</h1>
					<p>
					  Remi Forax
					</p>
				</section>
				<section>
					<h2>React ?</h2>
					<blockquote cite="https://en.wikipedia.org/wiki/React_(JavaScript_library)">
					  &ldquo; Front-end JavaScript library for building user interfaces based on UI components.
            React can be used as a base in the development of single-page, mobile, or server-rendered applications ...
            However, React is only concerned with state management and rendering that state to the DOM ...&rdquo;
					</blockquote>
           <p align="right">
             source: Wikipedia.org - <a href="https://en.wikipedia.org/wiki/React_(JavaScript_library)">React</a>
           </p>
				</section>
				<section>
					<h2>JavaScript ?</h2>
					<blockquote cite="https://en.wikipedia.org/wiki/React_(JavaScript_library)">
					  &ldquo;Bibliothèque cliente JavaScript pour créer des interfaces utilisateur à base de composants.
            React peut être utilisé comme base pour le développement d'applications Web à page unique, sur mobile
            ou générées coté serveur.
            React s'occupe uniquement de la gestion des états et de l'affichage ces états sur l'arbre DOM...
            &rdquo;
					</blockquote>
          <p align="right">
            source: Wikipedia.org - <a href="https://en.wikipedia.org/wiki/React_(JavaScript_library)">React</a>
          </p>
				</section>
        <section>
					<h2>Historique des versions</h2>
					<table>
           <tr>
            <td>React 0.3.0</td><td>2013</td>
           </tr><tr>
            <td>React 15 (ex 0.15.0)</td><td>2016</td>
           </tr><tr>
            <td>React 16.8 (Hooks)</td><td>2019</td>
           </tr><tr>
            <td>React 18</td><td>2022</td>
           </tr>
          </table>
          <small>Open Source, maintenu par Meta (ex Facebook)</small>
				</section>

        <section>
				    <h2>React ?</h2>
            <ul>
              <li>Des composants sous forme de fonctions (ou classes)</li>
              <li>JSX : JavaScript Syntax eXtension (optionnel)</li>
			  <li>Deux points d'entrées : React et ReactDOM</li>
              <li>Utilise un DOM virtuel mutable</li>
              <li>Gère ses propres évènements</li>
            </ul>
				</section>
				<section>
          <h2>Exemple simple</h2>
          <p>
			<a href="https://react.dev/reference/react-dom/client/createRoot#createroot">createRoot</a>(domNode)
			demande à React de gérer le nœud du DOM
		   <br/>
			<a href="https://react.dev/reference/react-dom/client/createRoot#root-render">render</a>(element)
			affiche l'élément JSX en tant que fils de la racine
          </p>
					<pre><code>
      &lt;div id="react-simple"&gt;&lt;/div&gt;
					</code></pre>
					<p>&nbsp;</p>
					<div id="react-simple"></div>

          <small><textarea autojslog="react-simple-example" rows="4" cols="55">
let node = document.getElementById("react-simple");
let root = ReactDOM.createRoot(node);
root.render(<i>Hello World !</i>);
          </textarea></small>
          <p></p>
          <small><div id="react-simple-example"></div></small>
				</section>

				<section>
					<h2>JavaScript Syntax eXtension</h2>
					<p>
                     Permet d'écrire du HTML comme une expression JavaScript
					<br/>
					 On utilise '{' et '}' pour insérer une expression JavaScript dans le JSX
					</p>
					<p>&nbsp;</p>
					<div id="react-jsx"></div>

					<small><textarea autojslog="react-jsx-example" rows="5" cols="55">
let value = 3;
let node = document.getElementById("react-jsx");
let root = ReactDOM.createRoot(node);
root.render(<div align="center">result = {value} !</div>);
          </textarea></small>
					<p><small>Nécessite un pré-processeur sur le code comme
						<a href="https://babeljs.io/repl/#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=false&corejs=3.21&spec=false&loose=false&code_lz=GYVwdgxgLglg9mABACQKYBt1wBQEpEDeAvgFAmiSwKIAiqAtjvgSYogE6pQjtIA8AExgA3AHx80mOOID0krOPnS-cjApVCxAbhKkgA&debug=false&forceAllTransforms=false&modules=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=env%2Creact%2Cstage-2&prettier=false&targets=&version=7.24.6&externalPlugins=&assumptions=%7B%7D">Babel</a>
						ou esbuild
					</small></p>
					<small><div id="react-jsx-example"></div></small>
				</section>

				<section>
				<h2>Traduction du JSX</h2>
				<p>
					Le JSX est transformé en appel à
				<br/>
                 <a href="https://react.dev/reference/react/createElement">React.createElement</a>(type, props, ...children)
				</p>
				<p>&nbsp;</p>
				<div id="react-jsx2"></div>

				<small><textarea autojslog="react-jsx-translation" rows="6" cols="76">
let value = 42;
let node = document.getElementById("react-jsx2");
let root = ReactDOM.createRoot(node);
root.render(<div align="center">result = {value} !</div>);
//root.render(React.createElement("div", { align: "center" }, "result = ", value, " !"));
          </textarea></small>
					<p><small>"props" veut dire properties !</small></p>
				  <small><div id="react-jsx-translation"></div></small>
				</section>

				<section>
					<h2><a href="https://esbuild.github.io/">esbuild</a></h2>
						<ul>
							<li>transforme les fichiers JSX (toto.jsx) en fichier JS (toto.js)</li>
							<li>inclu (<i>bundle</i>) les libraries (react et react-dom)</li>
						</ul>
					<p><small>
						Installation de esbuild en utilisant npm<br/>
						<code>
							npm install --save-exact --save-dev esbuild
						</code>
					</small></p>
					<p><small>
						Transpilation de JSX vers JS<br/>
						<code>
							./node_modules/.bin/esbuild toto.jsx --bundle --outfile=toto.js
						</code>
					</small></p>
					<p><small>L'option --watch permet de rebuilder automatiquement</small></p>

				</section>

				<section>
					<h2>Fonction comme composant</h2>
				</section>

				<section>
					<h2>Les composants comme fonctions</h2>
					<p>
           On déclare un composant réutilisable avec une fonction
					</p>
					<p>&nbsp;</p>
					<div id="react-root"></div>

					<small><textarea autojslog="react-component-example" rows="7" cols="62">
function Hello() {
  return <i>Hello !</i>;
}
let node = document.getElementById("react-root");
let root = ReactDOM.createRoot(node);
root.render(<div><Hello></Hello><Hello></Hello></div>);
          </textarea></small>
					<p><small>JSX fait la différence entre
					<a href="https://babeljs.io/repl/#?code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8tAEhlmwPSeZw2_brT5dBoxqwDcRAL5EgA">une fonction ou un tag HTML</a>
					avec les majuscules !</small></p>
					<small><div id="react-component-example"></div></small>
				</section>

				<section>
					<h2>Balise auto-fermante</h2>
					<p>
                     Comme un composant peut avoir n'importe quel nom,
					 <br/>
                     il existe une syntaxe pour "auto-fermer" une balise.
					</p>
					<p>&nbsp;</p>
					<div id="react-root2"></div>

					<small><textarea autojslog="react-jsx-autoclose" rows="7" cols="55">
function Hello() {
  return <i>Hello !</i>;
}
let node = document.getElementById("react-root2");
let root = ReactDOM.createRoot(node);
root.render(<div><Hello/><Hello/></div>);
          </textarea></small>
					<p><small>Cette notation vient du <a href="https://www.w3.org/TR/xhtml1/">XHTML</a></small></p>
					<small><div id="react-jsx-autoclose"></div></small>
				</section>

				<section>
					<h2>Propriété des composants</h2>
					<p>
						Les attributs JSX sont transformés en Objet ("props")
						pris en paramètre de la fonction
					</p>
					<p>&nbsp;</p>
					<div id="react-prop"></div>

					<small><textarea autojslog="react-prop-example" rows="8" cols="70">
function Hello(props) {
  let name = props.name;
  return <span>Hello { name } !</span>;
}
let node = document.getElementById("react-prop");
let root = ReactDOM.createRoot(node);
root.render(<div><Hello name="a"/><Hello name="b"/></div>);
          </textarea></small>
					<p><small></small></p>
					<small><div id="react-prop-example"></div></small>
				</section>

				<style>
				  .tomato {
				    color: tomato;
				    background-color: blue;
				  }
				</style>

				<section>
					<h2>Style d'un composant</h2>
					<p>
						On utilise plutôt l'attribut DOM "className" que "class" pour spécifier la classe CSS
					</p>
					<small><pre><code>
.tomato {
  color: tomato;
  background-color: blue;
}
					</code></pre></small>
					<div id="react-classname"></div>

					<small><textarea autojslog="react-classname-example" rows="9" cols="60">
function Hello(props) {
  let name = props.name;
  return <span className={ name }>Hello !</span>;
  //return <span class={ name }>Hello !</span>;
}
let node = document.getElementById("react-classname");
let root = ReactDOM.createRoot(node);
root.render(<div><Hello name="tomato"/></div>);
          </textarea></small>
					<p><small>
						<a href="https://stackoverflow.com/questions/46989454/class-vs-classname-in-react-16">Pour éviter la confusion avec le mot-clé "class"</a>
					</small></p>
					<small><div id="react-classname-example"></div></small>
				</section>

				<section>
					<h2>Fragment</h2>
					<p>
						Il existe une syntaxe spéciale (&lt;&gt; et &lt;/&gt;) pour encapsuler plusieurs
						éléments et les renvoyer comme un seul élément
					</p>

					<div id="react-fragment"></div>

					<small><textarea autojslog="react-fragment-example" rows="10" cols="60">
function Story() {
  return <>
      <div>Titre</div>
      <div>blah blah</div>
    </>;
}
let node = document.getElementById("react-fragment");
let root = ReactDOM.createRoot(node);
root.render(<div><Story/></div>);
          </textarea></small>
					<p></p>
					<small><div id="react-fragment-example"></div></small>
				</section>

				<section>
					<h2>JSX conditionnel</h2>
					<p>
						JSX a une syntax spécial pour afficher de façon conditionnelle
						<pre><code>
    condition && &lt;Whatever/&gt;
				    </code></pre>
					<p></p>
					<div id="react-conditional"></div>
					<small><textarea autojslog="react-conditional-example" rows="8" cols="70">
function Hello(prop) {
  return prop.visible && <span>Hello !</span>;
  //return prop.visible? <span>Hello !</span>: "";
}
let node = document.getElementById("react-conditional");
let root = ReactDOM.createRoot(node);
root.render(<div><Hello visible={true}/><Hello visible={false}/></div>);
          </textarea></small>
					<p><small></small></p>
					<small><div id="react-conditional-example"></div></small>
				</section>

				<section>
					<h2>Le DOM virtuel</h2>
				</section>

				<section>
					<h2>Virtual DOM ?</h2>
					<small><p>
						Le DOM virtuel est une copie du DOM qui utilise des objets JS
						plutôt que des objets C++
					</p></small>
					<img src="images/react/virtual-dom.png" width="320" height="236">
					<small><p>
						Lors d'un render(element), React regarde la différence entre l'arbre des élements
						et le DOM virtuel
					   <br/>
						Puis, React applique uniquement les changements sur le DOM !
					</p></small>
				</section>

				<section>
					<h2>Les listes</h2>
				</section>

				<section>
					<h2>Une liste simple</h2>
					<p>
						Le code ci-dessous à un problème (cf la console)
					<br/>
						<small>Warning: Each child in a list should have a unique "key" prop.</small>
					</p>
					<div id="react-list"></div>
					<small><textarea autojslog="react-list-example" rows="9" cols="76">
function Item(props) { return <li>{props.name}</li>; }
function List(props) {
  let items = props.items;
  return <ul>{items.map(item => <Item name={item.name}/>)}</ul>;
}
let data = [{id: 23, name: "Scooby"}, {id: 37, name: "Crypto"}];
let node = document.getElementById("react-list");
ReactDOM.createRoot(node).render(<List items={data}/>);
          </textarea></small>
					<p>
						<small>React demande un attribut "key" pour tracker les items au niveau du DOM virtuel</small>
					</p>
					<small><div id="react-list-example"></div></small>
				</section>

				<section>
					<h2>L'attribut "key"</h2>
					<p>
						Doit être unique, permet de savoir quels items changent
					</p>
					<div id="react-list-item"></div>
					<small><textarea autojslog="react-list-item-example" rows="9" cols="76">
function Item(props) { return <li>{props.name}</li>; }
function List(props) {
  let items = props.items;
  return <ul>{items.map(item => <Item key={item.id} name={item.name}/>)}</ul>;
}
let data = [{id: 23, name: "Scooby"}, {id: 37, name: "Crypto"}];
let node = document.getElementById("react-list-item");
ReactDOM.createRoot(node).render(<List items={data}/>);
          </textarea></small>
					<p><small>Les attributs "key" doivent être stables !</small></p>
					<small><div id="react-list-item-example"></div></small>
				</section>

				<section>
					<h2><i>State Hooks</i></h2>
				</section>

				<section>
					<h2>Gestion des états / state hook</h2>
					<p>
						useState(initial) renvoie un tableau
						contenant la valeur actuelle (ou la valeur initiale si c'est la première fois)
						et une fonction qui met à jour la valeur <u>et</u> l'UI
					</p>
					<div id="react-state"></div>

					<small><textarea autojslog="react-state-example" rows="12" cols="65">
function Toggle() {
  let array = React.useState("empty");
  let name = array[0];     // value
  let setName = array[1];  // update function
  return <div>
     { name }
     <button onClick={ () => setName("clicked") }>Click me</button>
   </div>;
}
let node = document.getElementById("react-state");
ReactDOM.createRoot(node).render(<Toggle/>);
          </textarea></small>
					<p><small>React a sa propre gestion des évènements donc "onClick" au lieu de "onclick"</small></p>
					<small><div id="react-state-example"></div></small>
				</section>

				<section>
					<h2>State Hook (2)</h2>
					<p>
                     Chaque composant a son propre état
					</p>
					<div id="react-state2"></div>

					<small><textarea autojslog="react-state-example2" rows="10" cols="65">
function Counter() {
  let [count, setCount] = React.useState(0);
  return <span>
     <button onClick={ () => setCount(count + 1) }>+1</button>
	 &nbsp; { count }
   </span>;
}
let node = document.getElementById("react-state2");
ReactDOM.createRoot(node).render(<><Counter/> <Counter/></>);
          </textarea></small>
					<p><small>Note: let [a,b] = c <=> let a = c[0]; let b = c[1]</small></p>
					<small><div id="react-state-example2"></div></small>
				</section>

				<section>
					<h2>State Hook (3)</h2>
					<p>
						La fonction de mise à jour peut prendre une lambda en paramètre
						(oldValue =&gt; newValue)
					</p>
					<div id="react-state3"></div>

					<small><textarea autojslog="react-state-example3" rows="10" cols="65">
function Counter() {
  let [count, setCount] = React.useState(0);
  return <span>
     <button onClick={ () => setCount(val => val + 1) }>+1</button>
	 &nbsp; { count }
   </span>;
}
let node = document.getElementById("react-state3");
ReactDOM.createRoot(node).render(<><Counter/> <Counter/></>);
          </textarea></small>
					<p><small></small></p>
					<small><div id="react-state-example3"></div></small>
				</section>

				<section>
					<h2>State Hook (4)</h2>
					<p>
                     On utilise les props si on veut configurer les composants
					 avec des valeurs différentes.
					</p>
					<div id="react-state4"></div>

					<small><textarea autojslog="react-state-example4" rows="12" cols="70">
function Counter(props) {
  let {incr} = props;
  let [count, setCount] = React.useState(0);
  return <span>
     <button onClick={ () => setCount(val => val + incr) }>+{incr}</button>
	 &nbsp; { count }
   </span>;
}
let node = document.getElementById("react-state4");
ReactDOM.createRoot(node)
    .render(<><Counter incr={1}/> <Counter incr={10}/></>);
          </textarea></small>
					<p><small>Note: let {a,b} = c <=> let a = c.a; let b = c.b</small></p>
					<small><div id="react-state-example4"></div></small>
				</section>

				<section>
					<h2>State hooks et DOM virtuel</h2>
					<p>
						Les <i>states hooks</i> sont stockés dans un tableau associé à chaque nœud du DOM virtuel
					</p>
					<img src="images/react/virtual-dom-state-hooks.png" width="300" height="300">
					<p><small>
						Tant qu'un nœud n'est pas supprimé l'état persiste
					</small></p>
				</section>



				<section>
					<h2>Communication inter-composants</i></h2>
				</section>

				<section>
					<h2>set... en tant que props</h2>
					<p>
                     Le composant parent peut envoyer sa fonction de mise à jour (set...)
					 en tant que props des composants enfants
					</p>
					<div id="react-counter"></div>

					<small><textarea autojslog="react-counter-example" rows="14" cols="65">
function Counter() {
  let [count, setCount] = React.useState(0);
  return <div>{count} &nbsp;
     <Clicker update={ setCount } inc= {1}/>
     <Clicker update={ setCount } inc={10}/>
   </div>;
}
function Clicker(props) {
  let {update, inc} = props;
  return <button onClick={ () => update(v => v + inc) }>+{inc}</button>;
}
let node = document.getElementById("react-counter");
ReactDOM.createRoot(node).render(<Counter/>);
          </textarea></small>
					<p><small>Cette technique est appelé <i>render props</i></small></p>
					<small><div id="react-counter-example"></div></small>
				</section>

				<!-- section>
					<h2>Plusieurs <i>State Hooks</i> ?</h2>
					<p>
						On peut avoir plusieurs appels à useState() pourvu que cela soit toujours dans le même ordre !
					</p>
					<div id="react-calc"></div>

					<small><textarea autojslog="react-calc-example" rows="13" cols="78">
function Field(props) {
  let [value, setValue] = props.hook;
  let onChange = e => setValue(parseInt(e.target.value));
  return <input type="text" type="number" value={value} onChange={ onChange } />;
}
function Calc() {
  let [a, setA] = React.useState(0);
  let [b, setB] = React.useState(0);
  return <div><Field hook={[a, setA]}/> + <Field hook={[b, setB]}/> = {a+b}</div>;
}
let node = document.getElementById("react-calc");
ReactDOM.createRoot(node).render(<Calc/>);
          </textarea></small>
					<p><small>La propagation des valeurs se fait toujours du parent vers les enfants</small></p>
					<small><div id="react-calc-example"></div></small>
				</section -->

				<section>
					<h2><i>Effect Hook</i></h2>
				</section>

				<section>
					<h2><i>Effect Hook</i></h2>
					<p>
                     <a href="https://react.dev/reference/react/useEffect#useeffect">useEffect</a>(lambda, [val1, val2, etc])
					 execute la lambda après qu'une des valeurs ait changé
					</p>
					<div id="react-effect"></div>

					<small><textarea autojslog="react-effect-example" rows="10" cols="60">
function Counter() {
  let [count, setCount] = React.useState(0);
  React.useEffect(() => {
    console.log("count", count);
   }, [count]);
  return <button onClick={ () => setCount(c => c + 1) }> { count }</button>;
}
let node = document.getElementById("react-effect");
ReactDOM.createRoot(node).render(<Counter/>);
          </textarea></small>
					<p><small>Si on ne spécifie pas de valeurs, on exécute l'effet à chaque fois !</small></p>
					<small><div id="react-effect-example"></div></small>
				</section>

				<section>
					<h2><i>Effect Hook</i> (2)</h2>
					<p>
						useEffect(lambda, []), si on spécifie un tableau vide, l'effet est exécuté
						une fois à la création, une fois à la destruction
					</p>
					<div id="react-effect2"></div>

					<small><textarea autojslog="react-effect2-example" rows="10" cols="60">
function Counter() {
  let [count, setCount] = React.useState(0);
  React.useEffect(() => {
    console.log("count", count);
   }, []);
  return <button onClick={ () => setCount(c => c + 1) }> { count }</button>;
}
let node = document.getElementById("react-effect2");
ReactDOM.createRoot(node).render(<Counter/>);
          </textarea></small>
					<p><small></small></p>
					<small><div id="react-effect2-example"></div></small>
				</section>

				<section>
					<h2>Appel asynchrone</h2>
				</section>

				<section>
					<h2>Après un click</h2>
					<p>
						On met à jour en fonction du résultat de l'appel à fetch()
					</p>
					<div id="react-async1"></div>

					<small><textarea autojslog="react-async-example1" rows="19" cols="76">
async function fetchData() {
  return (await fetch("images/react/data.json")).json();  // FIXME
}
function Item(props) {
  let {value, id} = props;
  return <li key={id}>{value}</li>;
}
function List() {
  let [data, setData] = React.useState([]);
  return <div>
       <button onClick={ async () => setData(await fetchData()) }>Update</button>
	   <ul>
        { data.map(d => <Item id={d.id} value={d.value}/>) }
	   </ul>
	 </div>;
}
let node = document.getElementById("react-async1");
ReactDOM.createRoot(node).render(<List/>);
          </textarea></small>
					<p><small></small></p>
					<small><div id="react-async-example1"></div></small>
				</section>

				<section>
					<h2>Lors du chargement</h2>
					<p>
						On utilise useEffect(function, [])
					</p>
					<div id="react-async2"></div>

					<small><textarea autojslog="react-async-example2" rows="18" cols="76">
async function fetchData(setData) {
  let data = await (await fetch("images/react/data.json")).json();  // FIXME
  setData(data);
}
function Item(props) {
  let {value, id} = props;
  return <li key={id}>{value}</li>;
}
function List() {
  let [data, setData] = React.useState([]);
  React.useEffect(() => { fetchData(setData); }, []);
  return <ul>
        { data.map(d => <Item id={d.id} value={d.value}/>) }
	   </ul>;
}
let node = document.getElementById("react-async2");
ReactDOM.createRoot(node).render(<List/>);
          </textarea></small>
					<p><small>useEffect() ne permet pas les fonctions async, il faut passer setData en paramètre</small></p>
					<small><div id="react-async-example2"></div></small>
				</section>

				<section>
					<h2>Classe comme composant</h2>
					<p><small>
						(Ancienne façon de faire)
					</small></p>
				</section>

				<section>
					<h2>Les composants comme classe</h2>
					<p>
				   Les "props" sont passés à la construction. L'appel à super() les stocke dans "this.props".
					<br/>
				   render() est appelée pour l'affichage.
					</p>
					<p></p>
					<div id="react-class"></div>

					<small><textarea autojslog="react-class-example" rows="10" cols="65">
class Hello extends React.Component {
  constructor(props) { super(props); }
  render() {
    return <span>Hello { this.props.name } !</span>;
  }
}
let node = document.getElementById("react-class");
let root = ReactDOM.createRoot(node);
root.render(<div><Hello name="a"/><Hello name="b"/></div>);
          </textarea></small>
					<p><small></small></p>
					<small><div id="react-class-example"></div></small>
				</section>

				<section>
					<h2>États avec this.state / setState()</h2>
					<p>
           setState(object) prend un  objet en paramètre, recopie tous les champs dans "this.state"
					 puis change l'UI
					</p>
					<div id="react-setState"></div>

					<small><textarea autojslog="react-setState-example" rows="14" cols="75">
class MyButton extends React.Component {
  constructor() {
    super();  // obligatoire en JS
    this.state = { name: "not clicked" };
  }
  render() {
    return <div>
      { this.state.name }
      <button onClick={ () => this.setState({ name: "clicked"}) }>Click me</button>
    </div>;
} }
let node = document.getElementById("react-setState");
ReactDOM.createRoot(node).render(<MyButton/>);
          </textarea></small>
					<p><small>si on change "this.state" au lieu de setState, l'UI est pas mise à jour !</small></p>
					<small><div id="react-setState-example"></div></small>
				</section>

				<section>
					<h2>Méthode de mutation (1/2)</h2>
					<p>
						On écrit la gestion des évènements dans une méthode pour que le code soit plus lisible
					</p>
					<div id="react-mut-update"></div>

					<small><textarea autojslog="react-mut-update-example" rows="12" cols="67">
class Toggle extends React.Component {
  constructor() { super(); this.state = { value: false }; }
  toggled() { this.setState({ value: !this.state.value }); }
  render() {
    return <div>
      { "" + this.state.value }
      <input type="checkbox" onClick={ () => this.toggled() }/>
    </div>;
} }
let node = document.getElementById("react-mut-update");
ReactDOM.createRoot(node).render(<Toggle/>);
          </textarea></small>
					<p><small></small></p>
					<small><div id="react-mut-update-example"></div></small>
				</section>

				<section>
					<h2>Méthode de mutation (2/2)</h2>
					<p>
           Ou on utilise "bind(this)"
					</p>
					<div id="react-mut-update2"></div>

					<small><textarea autojslog="react-mut-update2-example" rows="12" cols="67">
class Toggle extends React.Component {
  constructor() { super(); this.state = { value: false }; }
  toggled() { this.setState({ value: !this.state.value }); }
  render() {
    return <div>
      { "" + this.state.value }
      <input type="checkbox" onClick={ this.toggled.bind(this) }/>
    </div>;
} }
let node = document.getElementById("react-mut-update2");
ReactDOM.createRoot(node).render(<Toggle/>);
          </textarea></small>
					<p><small></small></p>
					<small><div id="react-mut-update2-example"></div></small>
				</section>

				<section>
					<h2>setState et méthode d'update</h2>
					<p>
            Comme avec un <i>state hook</i>, setState peut prendre une méthode de mise à jour en paramètre
					</p>
					<div id="react-setState3"></div>

					<small><textarea autojslog="react-setState3-example" rows="12" cols="65">
class Counter extends React.Component {
  constructor() { super(); this.state = { count: 0 }; }
  clicked() { this.setState(state => ({ count: state.count + 1 })); }
  render() {
    return <button onClick={ this.clicked.bind(this) }>
        { this.state.count }
      </button>;
  }
}
let node = document.getElementById("react-setState3");
ReactDOM.createRoot(node).render(<Counter/>);
          </textarea></small>
					<p><small>Attention, lorsque l'on retourne un objet dans une lambda, il faut des parenthèses !</small></p>
					<small><div id="react-setState3-example"></div></small>
				</section>

				<section>
					<h2>Évènements et DOM virtuel</h2>
				</section>

				<section>
					<h2>Cycle de vie</h2>
					<p>
						componentDidMount() est appelée lorsque l'objet du DOM correspondant est créé.
					<br/>
						componentWillUnmount() est appelée lorsque l'objet du DOM disparait.
					</p>
					<div id="react-lifecycle"></div>

					<small><textarea autojslog="react-lifecycle-example" rows="8" cols="60">
class Foo extends React.Component {
  componentWillUnmount() { console.log("willUnmount"); }
  componentDidMount() { console.log("didMount"); }
  render() { return "Foo !"; }
}
let node = document.getElementById("react-lifecycle");
ReactDOM.createRoot(node).render(<h3><Foo/></h3>);
          </textarea></small>
					<small><div id="react-lifecycle-example"></div></small>
				</section>

				<section>
					<h2>Cycle de vie et état</h2>
					<p>
						Chaque mise à jour du DOM appelle componentDidUpdate()
						<br/>
						<small>(sauf la première qui utilise componentDidMount)</small>
						<br>
						<small>useEffect = componentDidMount + componentDidUpdate</small>
					</p>
					<div id="react-lifecycle-state"></div>

					<small><textarea autojslog="react-lifecycle-state-example" rows="13" cols="77">
class Counter extends React.Component {
  constructor() { super(); this.state = { count: 0 }; }
  componentWillUnmount() { console.log("willUnmount"); }
  componentDidMount() { console.log("didMount"); }
  componentDidUpdate() { console.log("didUpdate"); }
  render() {
    return <button onClick={ () => this.setState(state => ({ count: state.count + 1 })) }>
        { this.state.count }
      </button>;
} }
let node = document.getElementById("react-lifecycle-state");
ReactDOM.createRoot(node).render(<Counter/>);
          </textarea></small>
					<small><div id="react-lifecycle-state-example"></div></small>
				</section>

				<!-- section>
					<h2>Reconciliation</h2>
					<p>

					</p>
					<div id="react-diff"></div>

					<small><textarea autojslog="react-diff-example" rows="11" cols="60">
class Foo extends React.Component {
  componentWillUnmount() { console.log("willUnmount"); }
  componentDidMount() { console.log("didMount"); }
  componentDidUpdate() { console.log("didUpdate"); }
  render() { return "Foo !"; }
}
let node = document.getElementById("react-diff");
let root = ReactDOM.createRoot(node);
root.render(<h3><Foo/></h3>);
window.setTimeout(() => root.render(<h2><Foo/></h2>), 2000);
          </textarea></small>
					<small><div id="react-diff-example"></div></small>
				</section -->
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                                        { src: 'plugin/autoeval/autoeval.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
