<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>JavaScript - Classe</title>

		<meta name="description" content="javascript, data structure, DOM">
		<meta name="author" content="Remi Forax">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
		
		<!-- autojs result -->
		<style>
		  div.autojsresult {
		    text-align: left;
		    color: lime;
		  }
		  div.autojslog {
		    color: orange;
		  }
		  div.autojserror {
		    color: red;
		  }
		  .bad-container {
            position: relative;
            display:inline-block;
          }
		  .bad-image:after {
            content: url(images/js/bad.png);
            position: absolute;
            z-index: 9999;
            right: 5px;
            bottom: 0px;
          }
		</style>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
                                <section>
					<h1>JavaScript</h1>
                   <br/>
                     <h2>Classe</h2>
					<p>
					  Remi Forax
					</p>
				</section>

                <section>
                    <h2>Classe</h2>
                </section>
                <section>
                    <h2>Classe ?</h2>
                    <blockquote cite="https://en.wikipedia.org/wiki/Class_(computer_programming)">
                        &ldquo;In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods).&rdquo;
                    </blockquote>
                    <p align="right">
                        source: Wikipedia.org - <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)">Class</a>
                    </p>
                </section>
                <section>
                    <h2>Classe ?</h2>
                    <blockquote cite="https://en.wikipedia.org/wiki/Class_(computer_programming)">
                        &ldquo;En programmation orienté objet, une classe est un programme-code-template extensible pour créer des objets, fournissant des valeurs initiales pour l'état (les variables membres) et les implantations de comportement (fonction membres ou méthodes).&rdquo;
                    </blockquote>
                    <p align="right">
                        source : Wikipedia.org - <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)">Class</a>
                    </p>
                </section>

                <section>
                    <h2>Définition d'une classe</h2>
                    <p>
                        Une classe définie un modèle/<em>template</em> de création d'objets.
                       <br/>
                        On créé une instance (un objet) en utilisant l'opérateur <b>new</b>.
                    </p>

                    <small><textarea autojslog="js-class" rows="6" cols="35">
class Car {
}

let car = new Car();
console.log(car);
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-class" class="autojslog"></div>
                    </small>
                </section>

                <section>
                    <h2>Méthodes</h2>
                    <p>
                        Une classe contient des fonctions associées à un objet appelées méthodes.
                    </p>

                    <small><textarea autojslog="js-method" rows="9" cols="35">
class Hello {
  say(person) {
    console.log(`Hello ${person}`);
  }
}

let hello = new Hello();
hello.say("Bob");
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-method" class="autojslog"></div>
                    </small>
                </section>

                <section>
                    <h2>this ?</h2>
                    <p>
                      Dans une méthode, <b>this</b> est un paramétre implicite correspondant à l'objet
                      sur lequel une méthode est appelée
                    </p>

                    <small><textarea autojslog="js-this" rows="10" cols="35">
class Person {
  hello(/* this */) {
    console.log(this.name);
  }
}

let person = new Person();
person.name = "Bob";
person.hello();
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-this" class="autojslog"></div>
                    </small>
                </section>

            <section>
                <h2>Constructeur</h2>
                <p>
                    On évite d'initialiser les champs directement, car
                   <br/>
                    une classe contient une méthode qui se charge de l'initialisation
                    appelé <b>constructeur</b>.
                </p>

                <small><textarea autojslog="js-constructor" rows="13" cols="35">
class Person {
  constructor(name) {
    this.name = name;
  }
  hello() {
    console.log(this.name);
  }
}

let person = new Person("Bob");
//person.name = "Bob";
person.hello();
                                        </textarea></small>
                <p></p>
                <small>
                    <div id="js-constructor" class="autojslog"></div>
                </small>
            </section>

            <section>
                <h2>Constructeur et this</h2>
                <p>
                    Au début du constructeur <b>this</b> vaut <b>{}</b> !
                </p>

                <small><textarea autojslog="js-constructor-this" rows="12" cols="35">
class Point {
  constructor(x, y) {
    console.log(this);
    this.x = x;
    console.log(this);
    this.y = y;
    console.log(this);
  }
}

new Point(1, 3);
                                        </textarea></small>
                <p></p>
                <small>
                    <div id="js-constructor-this" class="autojslog"></div>
                </small>
            </section>

                <section>
                    <h2>Classe ?</h2>
                    <p>
                        Une classe sert à regrouper au même endroit les fonctions/méthodes
                        qui travail sur des objets ayant la même structure (les mêmes propriétés)
                    </p>

                    <small><textarea autojslog="js-class-example" rows="12" cols="40">
class Square {
  constructor(side) {
    this.side = side;
  }
  surface() {
    return this.side * this.side;
  }
}

console.log(new Square(2).surface());
console.log(new Square(3).surface());
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-class-example" class="autojslog"></div>
                    </small>
                </section>

                <section>
                    <h2>Accès au Champs/Méthodes </h2>
                    <p>
                        <b>this</b> doit être écrit explicitement pour l'accès
                        aux champs/méthodes (pas comme C++/Java)
                    </p>

                    <small><textarea autojslog="js-class-java" rows="12" cols="40">
class Car {
  constructor(driver) {
    this.driver = driver;
  }
  driverName() {
    return driver;  // this.driver
  }
}

let car = new Car("Bob");
console.log(car.driverName());
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-class-java" class="autojslog"></div>
                    </small>
                </section>

                <section>
                    <h1>Classes et méthodes prédéfinies</h1>
                </section>

                <section>
                    <h2>Classe prédéfinie&nbsp;: tableau</h2>
                    <p>
                        Pour JavaScript, un tableau (<b>Array</b>) est un objet,
                        <br/>
                        <b>length</b> est une propriété des objets tableaux
                    </p>
                    <p>&nbsp;</p>
                    <small><textarea autojs="js-class-builtin-array" rows="9" cols="40">
let array = [1, 2, 4];
// propriété
array.length
// méthode
array.slice(1)

let array2 = new Array();
array2.length
                                        </textarea></small>
                    <small><div id="js-class-builtin-array"></div></small>
                </section>
                <section>
                    <h2>Classe prédéfinie&nbsp;: function</h2>
                    <p>
                        Pour JavaScript, une function (<b>Function</b>) est un objet,
                        <br/>
                        <b>name</b> ou <b>length</b> sont des propriétés des objets fonctions
                    </p>
                    <p>&nbsp;</p>
                    <small><textarea autojs="js-class-builtin-function" rows="10" cols="45">
let f = function plus(x) { return x + 2 };
// propriété
f.name
// méthode
f.toString()

let f2 = new Function("a", "b", "return a + b;");
f2(1, 2)
f2.length
                                        </textarea></small>
                    <small><div id="js-class-builtin-function"></div></small>
                    <p><small>
                        <b>length</b> renvoie le nombre de paramètres
                    </small><p>
                </section>
                <section>
                    <h2>Function.apply / Function.call</h2>
                    <p>
                        L'appel de fonction est équivalent
                        à l'appel de la méthode <b>call(undefined, arguments...)</b> sur la fonction.
                       <br/>
                        Le premier paramètre est la valeur de <b>this</b>.
                    </p>
                    <p>&nbsp;</p>
                    <small><textarea autojs="js-class-apply-call" rows="5" cols="45">
let f = function add(a, b) { return  a + b };
f(1, 2)
f.call(undefined, 1, 2);
f.apply(undefined, [1, 2]);
                                        </textarea></small>
                    <small><div id="js-class-apply-call"></div></small>
                    <p><small>
                        <b>apply()</b> prend un tableau tandis que <b>call</b> prend
                        les arguments séparés par des virgules
                    </small><p>
                </section>
                <section>
                    <h2>Appel de méthode</h2>
                    <p>
                        L'appel de méthode est équivalent
                        à l'appel de la méthode <b>call(objet, arguments..)</b> sur le champ de l'objet.
                    </p>
                    <p>&nbsp;</p>
                    <small><textarea autojslog="js-class-method-call" rows="8" cols="55">
class Person {
  constructor(name) { this.name = name; }
  say(message) { return `${message} from ${this.name}`; }
}
let p = new Person("Bob");
console.log(p.say.call(p, "Hello"));
console.log(p.say.apply(p, ["Hello"]));
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-class-method-call" class="autojslog"></div>
                    </small>
                </section>
                <section>
                    <h2>Function.bind</h2>
                    <p>
                        Permet de créer une fonction à partir d'une fonction existante
                        en indiquant la valeur des premiers arguments.
                    </p>
                    <p>&nbsp;</p>
                    <small><textarea autojs="js-class-bind" rows="4" cols="45">
let f = function add(a, b) { return  a + b };
let f2 = f.bind(undefined, 42);
f2(3)
                                        </textarea></small>
                    <small><div id="js-class-bind"></div></small>
                    <p><small>
                        Attention, le premier argument est la valeur de <b>this</b>,
                        pas le premier paramètre !
                    </small><p>
                </section>
                <section>
                    <h2>Fonction anonyme vs this</h2>
                    <p>
                        Une fonction flèche capture <b>this</b>.
                        Une fonction classique prend <b>this</b> lors de l'appel (le paramètre devant le '.').
                    </p>
                    <p>&nbsp;</p>
                    <small><textarea autojslog="js-arrow-this" rows="9" cols="55">
class Eval {
  constructor(x) { this.x = x; }
  add() { return v => this.x + v; }
  add2() { return function(v) { return this.x + v; }; }
}
let eval = new Eval(40);
console.log(eval.add()(2));
console.log(eval.add2()(2));
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-arrow-this" class="autojslog"></div>
                    </small>
                </section>
                <section>
                    <h2>Fonction anonyme + bind(this)</h2>
                    <p>
                        Si on est en ECMAScript < 6, on peut s'en sortir en ajoutant
                        un <b>bind(this)</b>.
                    </p>
                    <p>&nbsp;</p>
                    <small><textarea autojslog="js-bind-this" rows="9" cols="55">
class Eval {
  constructor(x) { this.x = x; }
  add() { return v => this.x + v; }
  add2() { return function(v) { return this.x + v; }.bind(this); }
}
let eval = new Eval(40);
console.log(eval.add()(2));
console.log(eval.add2()(2));
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-bind-this" class="autojslog"></div>
                    </small>
                </section>
                <section>
                    <img src="images/js-object/this_is_bullshit.png">
                </section>

                <section>
                    <h1>Down the Rabbit Hole</h1>
                </section>

                <section>
                    <h2>Et sans le mot-clé <b>class</b> ?</h2>
                    <p>
                        Le mot-clé <b>class</b> existe que depuis ECMAScript 6,
                        avant on écrivait un code un peu différent.
                       <br/>
                        Pour cela, il va falloir regarder comment le mot-clé "class"
                        marche vraiment ...
                    </p>
                </section>

                <section>
                    <h2>Une classe est une fonction !</h2>
                    <p>
                        En JavaScript, une classe est une fonction !
                    </p>
                    <small><textarea autojslog="js-class-as-function" rows="9" cols="40">
class Car {
  constructor(driver) {
    this.driver = driver;
  }
}

console.log(typeof Car);
console.log(Car instanceof Function);
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-class-as-function" class="autojslog"></div>
                    </small>
                </section>
                <section>
                    <h2>Et une méthode est une fonction aussi !</h2>
                    <p>
                        Une méthode est une fonction stockée dans un objet
                        avec le nom de la méthode comme nom de clé/propriété.
                    </p>
                    <small><textarea autojslog="js-method-as-function" rows="7" cols="45">
let car = {
  driver: "Bob",
  driverName: function() { return this.driver; }
};
console.log(car);
console.log(car.driverName());
                    </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-method-as-function" class="autojslog"></div>
                    </small>
                </section>

                <section>
                    <h2>Object.create()</h2>
                    <p>
                        <b>Object.create(prototype)</b> permet de créer des objets comme <b>{}</b>
                        mais en indiquant un <b>[Prototype]</b>.
                    <br/>
                        Un <b>[Prototype]</b> est un objet dans lequel aller chercher si on
                        trouve pas dans l'objet courant
                    </p>
                    <small><textarea autojslog="js-object-create" rows="8" cols="40">
let oldPets = {};
oldPets.snoopy = "dog";
let newPets = Object.create(oldPets);
newPets.garfield = "cat";
newPets.scooby = "dog";
console.log(newPets.garfield);
console.log(newPets.scooby);
                    </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-object-create" class="autojslog"></div>
                    </small>
                </section>
                <section>
                    <h2>__proto__</h2>
                    <p>
                        On peut demander la valeur du <b>[Prototype]</b> d'un objet
                        avec la clé <b>__proto__</b>.
                    </p>
                    <small><textarea autojslog="js-proto" rows="8" cols="40">
let oldPets = {};
oldPets.snoopy = "dog";
let newPets = Object.create(oldPets);
newPets.garfield = "cat";
newPets.scooby = "dog";
console.log(newPets);
console.log(newPets.__proto__);
                    </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-proto" class="autojslog"></div>
                    </small>
                </section>

                <section>
                    <h2>Où sont les champs et les méthodes ?</h2>
                    <p>
                        Comme on veut partager les méthodes, on va les mettre
                        dans le <b>[Prototype]</b>
                    </p>
                    <small><textarea autojslog="js-layer" rows="10" cols="40">
let methods = {
  driverName: function() { return this.driver; }
};
let car1 = Object.create(methods);
car1.driver = "Bob";
let car2 = Object.create(methods);
car2.driver = "Ana";
console.log(car1.driverName());
console.log(car2.driverName());
                    </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-layer" class="autojslog"></div>
                    </small>
                </section>

                <section>
                    <h2>Comment on créer un objet en JavaScript &lt; 6</h2>
                    <p>
                        Une fonction joue le rôle de constructeur, le champ
                        <b>prototype</b> de cette fonction joue le rôle de conteneur de méthodes.
                    </p>
                    <small><textarea autojslog="js-old-new" rows="7" cols="50">
function Car(driver) { this.driver = driver; }
Car.prototype.driverName = function driverName() {
  return this.driver;
};
let car = new Car ("Bob");
console.log(car.driverName());
                    </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-old-new" class="autojslog"></div>
                    </small>
                </section>
                <section>
                    <h2>Classe, fonction et champ prototype</h2>
                    <p>
                        Une classe est vue comme une fonction dont le code appel le constructeur.
                        Les méthodes de la classe sont ajoutées au champ "prototype" de cette fonction.
                    </p>
                    <div style="float: left;">
                        <small><textarea autojslog="js-class-6a" rows="12" cols="32">
class Car {
  constructor(driver) {
    this.driver = driver;
  }
  driverName() {
    return this.driver;
  }
}

let car = new Car("Bob");
console.log(car.driverName());
                                        </textarea></small>
                        <p><small>JavaScript 6</small></p>
                        <small>
                            <div id="js-class-6a" class="autojslog"></div>
                        </small>
                    </div><div>
                    <small><textarea autojslog="js-class-6b" rows="12" cols="38">
function Car(driver) {
  this.driver = driver;
}

Car.prototype.driverName = function() {
  return this.driver;
};

let car = new Car("Bob");
console.log(car.driverName());
                                        </textarea></small>
                    <p><small>JavaScript &lt; 6</small></p>
                    <small>
                        <div id="js-class-6b" class="autojslog"></div>
                    </small>
                </div>
                </section>
                <section>
                    <h2>Création d'un objet: comment cela marche ?</h2>
                    <p>
                        On peut écrire le code de <b>new</b> en JavaScript.
                        C'est <b>Object.create(fun.prototype)</b> + <b>fun.apply(...)</b>.
                    </p>
                    <small><textarea autojslog="js-my-new" rows="12" cols="50">
function myNew(fun, ...args) {
  var object = Object.create(fun.prototype);
  fun.apply(object, args);
  return object;
}
function Car(driver) { this.driver = driver; }
Car.prototype.driverName = function driverName() {
  return this.driver;
};
let car = myNew(Car, "Bob");  // <=> new Car("Bob");
console.log(car.driverName());
                    </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-my-new" class="autojslog"></div>
                    </small>
                </section>


                <section>
                    <h2>La notation "class"</h2>
                    <p>
                        La notation est un peu plus verbeuse que la notation classique,
                        donc quel est l'intérêt d'introduire cette nouvelle notation ?
                    </p>
                    <p class="fragment">
                        Permet de <b>regrouper</b> dans un même endroit l'initialisation et
                        la manipulation d'un type nommé
                    </p>
                    <p class="fragment">
                        La notion de classe <b>existe déjà</b> dans plusieurs autres languages (C++, Java, Swift, Rust)
                        et est donc mieux comprise que la notion de <b>[Prototype]</b> propre à JavaScript
                    </p>
                </section>

				<section>
					                    <span style="float: inline-block">
                                        <small><textarea autojscanvas="js-object-matrix" rows="25" cols="55">
let canvas = document.getElementById('js-object-matrix');
let context = canvas.getContext("2d");
let data = [ 'U', '-', 'E', 'I', 'F', 'F', 'E', 'L' ];
class Snake {
  constructor(x) {
    this.x = x;
    this.y = Math.floor(canvas.height * Math.random());
  }
  draw(context) {
    context.fillStyle = 'rgb(0, 255 , 0)';
    for(let i = 0; i < data.length; i++) {
      context.fillText(data[i], 15 * this.x, this.y - 15 * i);
      context.fillStyle = 'rgb(0, 176, 0)';
    }
    this.y = this.y + 10;
    if (this.y > canvas.height) this.y = 0;
  }
}
let snakes = [];
for(let i = 0; i < 20; i++) { snakes.push(new Snake(i)); }
window.setInterval(() => {
  context.clearRect(0, 0, canvas.width, canvas.height);
  snakes.forEach(snake => snake.draw(context));
}, 50);
                                          
                                        </textarea></small>
                                        </span><span style="display: inline-block">
                                        <canvas id="js-object-matrix"
                                                width="300"
                                                height="600">
                                        </canvas>
                                        </span>  
                                        
				</section>
			
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                                        { src: 'plugin/autoeval/autoeval.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
