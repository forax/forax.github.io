<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>JavaScript - Classe</title>

		<meta name="description" content="javascript, data structure, DOM">
		<meta name="author" content="Remi Forax">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
		
		<!-- autojs result -->
		<style>
		  div.autojsresult {
		    text-align: left;
		    color: lime;
		  }
		  div.autojslog {
		    color: orange;
		  }
		  div.autojserror {
		    color: red;
		  }
		  .bad-container {
            position: relative;
            display:inline-block;
          }
		  .bad-image:after {
            content: url(images/js/bad.png);
            position: absolute;
            z-index: 9999;
            right: 5px;
            bottom: 0px;
          }
		</style>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
                                <section>
					<h1>JavaScript</h1>
                   <br/>
                     <h2>Classe</h2>
					<p>
					  Remi Forax
					</p>
				</section>

                <section>
                    <h2>Les Classes</h2>
                </section>

                <section>
                    <h2>Définition d'une classe</h2>
                    <p>
                        Une classe définit un modèle de création d'objets.
                    </p><p>
                    Une classe contient des <b>méthodes</b> (fonctions qui agissent sur <b>this</b>) et
                    un <b>constructeur</b> (méthode d'initialisation)
                </p>

                    <small><textarea autojslog="js6-class" rows="13" cols="35">
class Car {
  constructor(driver) {
    this.driver = driver;
    this.wheels = 4;
  }
  driverName() {
    return this.driver;
  }
}

let car = new Car("bob");
console.log(car.driverName());
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js6-class" class="autojslog"></div>
                    </small>
                </section>
                <section>
                    <h2>Classe et délégué/prototype</h2>
                    <p>
                        Une classe est vue comme une fonction dont le code appelle le constructeur.
                        Les méthodes de la classe sont ajoutées au prototype de la fonction.
                    </p>
                    <div style="float: left;">
                        <small><textarea autojslog="js6-class3a" rows="12" cols="35">
class Square {
  constructor(side) {
    this.side = side;
  }
  surface() {
    return this.side * this.side;
  }
}

let square = new Square(3);
console.log(square.surface());
                                        </textarea></small>
                        <p><small>JavaScript 6</small></p>
                        <small>
                            <div id="js6-class3a" class="autojslog"></div>
                        </small>
                    </div><div>
                    <small><textarea autojslog="js6-class3b" rows="12" cols="35">
function Square(side) {
  this.side = side;
}

Square.prototype.surface = function() {
  return this.side * this.side;
};

let square = new Square(3);
console.log(square.surface());
                                        </textarea></small>
                    <p><small>JavaScript &lt; 6</small></p>
                    <small>
                        <div id="js6-class3b" class="autojslog"></div>
                    </small>
                </div>
                </section>
                <section>
                    <h2>La notation "class"</h2>
                    <p>
                        La notation est un peu plus verbeuse que la notation classique,
                        donc quel est l'intérêt d'introduire cette nouvelle notation ?
                    </p>
                    <p class="fragment">
                        Permet de <b>regrouper</b> dans un même endroit l'initialisation et la manipulation d'un type nommé
                    </p>
                    <p class="fragment">
                        La notion de classe <b>existe déjà</b> dans plusieurs autres languages (C++, Java, Swift, Rust) et est donc mieux comprise que la notion de délégation propre à JavaScript
                    </p>
                </section>
                <section>
                    <h2>Héritage</h2>
                </section>
                <section>
                    <h2>Héritage</h2>
                    <p>
                        Définir une classe en étendant des propriétés d'une classe existante
                    </p>
                    <p>&nbsp;</p>
                    <small><textarea autojslog="js6-class-inheritance" rows="11" cols="45">
class A {
  hello() { return "hello"; }
}
class B extends A {
  msg(name) { return this.hello() + " " + name; }
}

let b = new B();
console.log(b.hello());
console.log(b.msg("bob"));
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js6-class-inheritance" class="autojslog"></div>
                    </small>
                </section>
                <section>
                    <h2>super()</h2>
                    <p>
                        super() permet d'appeler le constructeur de la super-classe
                    </p>
                    <p>&nbsp;</p>
                    <small><textarea autojslog="js6-class-super" rows="11" cols="45">
class Box {
  constructor(x) { this.x = x; }
  str() { return this.x; }
}
class Point extends Box {
  constructor(x, y) { super(x); this.y = y; }
}

let array = [new Box(3), new Point(1, 2)];
array.map(v => v.str()).forEach(console.log);
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js6-class-super" class="autojslog"></div>
                    </small>
                </section>
                <section>
                    <h2>super.m()</h2>
                    <p>
                        Une propriété cache la propriété existante dans la super classe,
                        super.m() permet d'accéder à la méthode m de la super classe
                    </p>

                    <small><textarea autojslog="js6-class-super2" rows="11" cols="45">
class Box {
  constructor(x) { this.x = x; }
  str() { return this.x; }
}
class Point extends Box {
  constructor(x, y) { super(x); this.y = y; }
  str() { return super.str() + ", " + this.y; }
}
let array = [new Box(3), new Point(1, 2)];
array.map(v => v.str()).forEach(console.log);
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js6-class-super2" class="autojslog"></div>
                    </small>
                </section>

                <section>
                    <h2>Problème de l'héritage</h2>
                    <p>
                        Si on insère une méthode dans une super-classe,
                        <br/>
                        il <b>faut redéfinir</b> celle-ci dans toutes les sous-classes
                    </p>
                    <small><div class="bad-container"><textarea autojslog="js6-class-inherit" rows="13" cols="45">
class Square {
  constructor(side) { this.side = side; }
  surface() { return this.side * this.side; }
}
class Rectangle extends Square {
  constructor(width, height) {
    super(width); this.height = height;
  }
  //surface() { return this.width * this.height; }
}
var array = [new Square(3), new Rectangle(2, 3)];
console.log(array.map(e => e.surface()));
                                        </textarea><div class="bad-image"></div></div></small>
                    <p></p>
                    <small>
                        <div id="js6-class-inherit" class="autojslog"></div>
                    </small>
                </section>
                <section>
                    <h2>Les limites de l'héritage</h2>
                    <p>
                        En fait, l'héritage sert pas à grand chose en JavaScript,
                        on peut toujours faire sans !
                    </p>
                    <small><textarea autojslog="js6-inherit-limit2" rows="13" cols="45">
class Square {
  constructor(side) { this.side = side; }
  surface() { return this.side * this.side; }
}
class Rectangle {
  constructor(width, height) {
    this.width = width; this.height = height;
  }
  surface() { return this.width * this.height; }
}
var array = [new Square(3), new Rectangle(2, 3)];
console.log(array.map(e => e.surface()));
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js6-inherit-limit2" class="autojslog"></div>
                    </small>
                </section>

                <section>
                    <h2>Objet prédéfini&nbsp;: tableau</h2>
                    <p>
                        Pour JavaScript, un tableau (<b>Array</b>) est un objet,
                        <br/>
                        <b>length</b> est une propriété des objets tableaux
                    </p>
                    <p>&nbsp;</p>
                    <small><textarea autojs="js-object-builtin-array" rows="9" cols="40">
let array = [1, 2, 4];
// propriété
array.length
// méthode
array.slice(1)

let array2 = new Array();
array2.length
                                        </textarea></small>
                    <small><div id="js-object-builtin-array"></div></small>
                    <p><small>
                        La syntaxe <b>new</b> permet de créer un objet
                    </small><p>
                </section>
                <section>
                    <h2>Objet prédéfini&nbsp;: function</h2>
                    <p>
                        Pour JavaScript, une function (<b>Function</b>) est un objet,
                        <br/>
                        <b>name</b> ou <b>length</b> sont des propriétés des objets fonctions
                    </p>
                    <p>&nbsp;</p>
                    <small><textarea autojs="js-object-builtin-function" rows="10" cols="45">
let f = function plus(x) { return x + 2 }
// propriété
f.name
// méthode
f.toString()

let f2 = new Function("a", "b", "return a + b;");
f2(1, 2)
f2.length
                                        </textarea></small>
                    <small><div id="js-object-builtin-function"></div></small>
                    <p><small>
                        <b>length</b> renvoie le nombre de paramètres
                    </small><p>
                </section>
				
				<section>
					                    <h2>Fonction vs Méthode</h2>
					                    <p>
					                     Un objet peut aussi contenir des fonctions comme valeurs
					                    <br/>
					                     Une fonction dans un objet est appelé une <b>méthode</b>
                                        </p>
                                        <small><textarea autojslog="js-object-method" rows="10" cols="40">
var square = {
  surface: function(x) { return x * x; }
};
var disc = {
  surface: function(r) { return Math.PI * r * r; }
};

console.log(square.surface(3));
console.log(disc.surface(3));
                                        </textarea></small>
                                        <p></p>
                                        <small>
                                          <div id="js-object-method" class="autojslog"></div>
                                        </small>
                                        <p></p>
				</section>
				<section>
					                    <h2>this</h2>
					                    <p>
					                     Paramètre implicite qui contient l'objet sur lequel
					                    <br/>
					                     on a appelé une méthode
					                    <br/>
					                     (l'objet sur lequel on utilise l'opérateur '.')
                                        </p>
                                        <small><textarea autojslog="js-object-this" rows="8" cols="40">
var square = {
  side: 2,
  surface: function() {
   return this.side * this.side;
  }
};
console.log(square.surface());
                                        </textarea></small>
                                        <p></p>
                                        <small>
                                          <div id="js-object-this" class="autojslog"></div>
                                        </small>
                                        <p>&nbsp;</p>
				</section>
				
				<section>
					                    <h2>this et appel de fonction</h2>
					                    <p>
					                     Que vaut <b>this</b> si on appel comme une fonction ?
                                        </p>
                                        <small><div class="bad-container"><textarea autojslog="js-object-this2" rows="10" cols="40">
"use strict";
function isAdult() {
  return this.age >= 18;
}

var person = { age: 32, hasGrownUp: isAdult };
console.log(person.hasGrownUp());

console.log(isAdult(person));
                                        </textarea><div class="bad-image"></div></div></small>
                                        <p></p>
                                        <small>
                                          <div id="js-object-this2" class="autojslog"></div>
                                        </small>
                                        <p>
                                         <b>isAdult</b> ne prend pas d'argument et "this" vaut undefined !
                                        </p>
				</section>
				<section>
		          <img src="images/js-object/this_is_bullshit.png">
				</section>
				
				<section>
					                    <h2>Partage de méthodes :(</h2>
					                    <p>
					                     Si on a deux objets, il faut définir <b>surface</b> deux fois,
					                    <br/> 
					                     même si c'est le même code !?
                                        </p>
                                        <small><div class="bad-container"><textarea autojslog="js-object-prototype" rows="11" cols="50">
var square1 = {
  side: 1,
  surface: function() { return this.side * this.side; }
};
var square2 = {
  side: 2,
  surface: function() { return this.side * this.side; }
};
console.log(square1.surface());
console.log(square2.surface());
                                        </textarea><div class="bad-image"></div></div></small>
                                        <p></p>
                                        <small>
                                          <div id="js-object-prototype" class="autojslog"></div>
                                        </small>
                                        <p>
                                         Ça parait idiot !
                                        </p>
				</section>
				<section>
					                    <h2>Partage de méthode (astuce)</h2>
					                    <p>
					                     Lorsque l'on cherche une propriété, si elle n'existe pas sur l'objet,
					                     on va chercher dans un objet délégué
                                        </p>
                                        <small><div class="bad-container"><textarea autojslog="js-object-prototype2" rows="11" cols="50">
var proto = {
  surface: function() { return this.side * this.side; }
};
var square1 = { side: 1 };
var square2 = { side: 2 };
Object.setPrototypeOf(square1, proto);
Object.setPrototypeOf(square2, proto);

console.log(square1.surface());
console.log(square2.surface());
                                        </textarea><div class="bad-image"></div></div></small>
                                        <p></p>
                                        <small>
                                          <div id="js-object-prototype2" class="autojslog"></div>
                                        </small>
                                        <p><small>
                                         <b>setPrototypeOf</b> permet d'indiquer pour un objet
                                        <br/> 
                                         son objet délégué
                                        </small></p>
				</section>
				<section>
					                    <h2>Le délégué</h2>
					                    <p>
					                     L'objet délégué est l'objet dans lequel on va chercher une propriété
					                     si celle-ci n'est pas définie sur l'objet courant
                                        </p>
                                        <small><div class="bad-container"><textarea autojslog="js-object-prototype3" rows="8" cols="50">
var proto = {
  surface: function() { return this.side * this.side; }
};
var square1 = { side: 1 };
Object.setPrototypeOf(square1, proto);

console.log(square1.__proto__ == proto);
                                        </textarea><div class="bad-image"></div></div></small>
                                        <p></p>
                                        <small>
                                          <div id="js-object-prototype3" class="autojslog"></div>
                                        </small>
                                        <p>
                                         On peut obtenir l'objet délégué avec la propriété <b>__proto__</b>
                                        </p>
				</section>
				<section>
					                    <h2>setPrototypeOf</h2>
					                    <p>
					                     Attention, changer le délégué d'un objet avec <b>setPrototypOf</b>
					                     alors que celui-ci est déjà créé
					                    <br/> 
					                     est souvent très lent !
					                    </p>
					                    <p>
					                     Firefox écrit même un message
					                     <span style="text-decoration: line-through;">d'insulte</span> d'information
					                    <br/> 
					                     sur la console
                                        </p>
                                        <p style="color: red">
mutating the [[Prototype]] of an object will cause your code to run very slowly;
instead create the object with the correct initial [[Prototype]] value using Object.create
                                        </p>
                                        <p>&nbsp;</p>
				</section>
				<section>
					                    <h2>La syntaxe New</h2>
					                    <p>
					                     <b>new</b> permet de créer des objets qui auront comme délégué
					                     la valeur de la propriété <b>prototype</b> d'une fonction
                                        </p>
                                        <small><textarea autojslog="js-object-new" rows="10" cols="60">
function Square(side) {
  this.side = side;
}
Square.prototype.surface = function() { return this.side * this.side; };

var square1 = new Square(1);
var square2 = new Square(2);
console.log(square1.surface());
console.log(square2.surface());
                                        </textarea></small>
                                        <p></p>
                                        <small>
                                          <div id="js-object-new" class="autojslog"></div>
                                        </small>
                                        <p><small>
                                         <b>new Square</b> crée un objet, initialise celui-ci avec la fonction <b>Square</b> et
                                        <br/>
                                         indique que son délégué est la valeur de <b>Square.prototype</b>
                                        </small></p>
				</section>
				<section>
					                    <h2>New et convention</h2>
					                    <p>
					                     Les fonctions utilisées par <b>new</b> ont un nom qui commence par une majuscule
                                        </p>
                                        <small><textarea autojslog="js-object-new2" rows="14" cols="60">
function Point(x, y) {
  this.x = x;
  this.y = y;
}
Point.prototype.distance = function(p) { 
  var dx = this.x - p.x;
  var dy = this.y - p.y;
  return Math.sqrt(dx * dx + dy * dy);
};

var p1 = new Point(0, 0);
var p2 = new Point(1, 1);
console.log(p1.distance(p2));
                                        </textarea></small>
                                        <p></p>
                                        <small>
                                          <div id="js-object-new2" class="autojslog"></div>
                                        </small>
                                        <p></p>
				</section>
				<section>
					                    <h2>Création d'objets</h2>
					                    <p>
					                     Deux syntaxes !
					                    </p>
					                    <dl>
					                     <dt>Avec les accolades :
					                     <dd>si on n'a que des valeurs, ou un seul objet
					                    <br/>
					                     <small><textarea rows="2" cols="35">
var foo = { key1: 2, key2: 'hello' };
					                     </textarea></small>
					                     <p></p>
					                     <dt>Avec new :
					                     <dd>si on a plusieurs objets avec des méthodes
					                     <small><textarea rows="6" cols="55">
function Foo(key1, key2) { this.key1 = key1; this.key2 = key2; }
Foo.prototype.meth1 = function(x) { return ...; };

var foo = new Foo(2, 'hello');
foo.meth1(false);
					                     </textarea></small>
					                    </dl>
				</section>
				
				<section>
					                    <h2>Exemple</h2>
					                    <span style="float: inline-block">
                                        <small><textarea autojscanvas="js-object-matrix" once="true" rows="23" cols="55">
var canvas = document.getElementById('js-object-matrix');
var context = canvas.getContext("2d"); 
var data = [ 'U', 'P', 'E', 'M' ];             
function Snake(x) {
  this.x = x;
  this.y = Math.floor(canvas.height * Math.random());
}
Snake.prototype.draw = function(context) {
  context.fillStyle = 'rgb(0, 255 , 0)';
  for(var i = 0; i < data.length; i++) {
    context.fillText(data[i], 15 * this.x, this.y - 15 * i);
    context.fillStyle = 'rgb(0, 164, 0)';
  }
  this.y = this.y + 10;
  if (this.y > canvas.height) this.y = 0;
}
snakes = [];
for(var i = 0; i < 20; i++) { snakes.push(new Snake(i)); }
window.setInterval(function() {
  context.clearRect(0, 0, canvas.width, canvas.height);
  snakes.forEach(function(snake) { snake.draw(context); });
}, 50);
                                          
                                        </textarea></small>
                                        </span><span style="display: inline-block">
                                        <canvas id="js-object-matrix"
                                                width="300"
                                                height="600">
                                        </canvas>
                                        </span>  
                                        
				</section>
			
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                                        { src: 'plugin/autoeval/autoeval.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
