<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>JavaScript - REST - AJAX</title>

		<meta name="description" content="javascript, REST, Promise">
		<meta name="author" content="Remi Forax">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
		
		<!-- autojs result -->
		<style>
		  div.autojsresult {
		    text-align: left;
		    color: lime;
		  }
		  div.autojslog {
		    color: orange;
		  }
		  div.autojserror {
		    color: red;
		  }
		  .bad-container {
            position: relative;
            display:inline-block;
          }
		  .bad-image:after {
            content: url(images/js/bad.png);
            position: absolute;
            z-index: 9999;
            right: 5px;
            bottom: 0px;
          }
		</style>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
                                <section>
					<h1>JavaScript</h1>
                    <br/>
                    <h2>API REST et AJAX</h2>
					<p>
					  Remi Forax
					</p>
				</section>

                <section>
                    <h2>Discussion client/serveur</h2>
                    <p>
                        Historiquement, un client (browser) et un serveur
                        discute par HTTP page par page
                    </p>
                    <img src="images/rest/server1.png"
                         width="400"
                         height="200">
                    <p>
                        <small>mais l'interactivité est limitée</small>
                    </p>
                </section>
                <section>
                    <h2>AJAX en 1999</h2>
                    <p>
                        Pour Asynchronous JavaScript And XML.
                        <small>
                            On sépare la page et le contenu
                            dynamique de la page. Le contenu dynamique est demandé en utilisant JavaScript.
                        </small>
                    </p>
                    <img src="images/rest/server2.png"
                         width="400"
                         height="200">
                    <p>
                        <small>mais on envoie des morceaux d'arbre DOM, beurk !</small>
                    </p>
                </section>
                <section>
                    <h2>JSON en 2001</h2>
                    <p>
                        Douglas Crockford invente JSON
                        <small>
                            un format d'échange simple indépendant d'un langage en particulier
                        </small>
                    </p>
                    <img src="images/rest/server3.png"
                         width="400"
                         height="200">
                    <p>
                        <small>utilise un sous-ensemble de la syntaxe des objets de JavaScript</small>
                    </p>
                </section>
                <section>
                    <h2>Architecture moderne</h2>
                    <p>
                        C'est le même serveur qui envoie les fichiers statiques et répond aux appels
                        effectuer en JavaScript. L'API est au format REST.
                    </p>
                    <img src="images/rest/server4.png"
                         width="400"
                         height="215">
                </section>

                <section>
                    <h2>Server REST</h2>
                </section>
                <section>
                    <h2>REST</h2>
                    <blockquote cite="https://en.wikipedia.org/wiki/Representational_state_transfer">
                        &ldquo;Representational state transfer (REST) or RESTful Web services are
                        one way of providing interoperability between computer systems on the Internet.
                        REST-compliant Web services allow requesting systems to access and manipulate
                        textual representations of Web resources using a uniform and predefined
                        set of stateless operations.&rdquo;
                    </blockquote>
                    <p align="right">
                        source: Wikipedia.org - <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">Representational state transfer</a>
                    </p>
                </section>

                                <section>
					                    <h2>Idée de REST</h2>
					                    <p>
                                         On réutilise le protocole HTTP pour faire
                                        <br/> 
                                         les appels à des services sur un serveur distant
                                        </p>
                                        <ul>
                                         <li>client-server mais sur HTTP
                                         <li>interface uniforme
                                         <li>sans état (stateless), cacheable + load balancer
                                        </ul>
				                </section>
				                
				                <section>
				                        <h2>Interface uniforme</h2>
				                        <ul>
				                         <li>On nomme des resources en utilisant des URIs
				                         <li>On utilise les méthodes HTTP comme action
				                          <br/>
				                           GET, PUT, POST, DELETE
				                         <li>La façon dont sont stockées les données est indépendante de la représentation.
				                         <li>On utilise XML et/ou JSON comme format de transport
				                        </ul>
				                </section>
				                
				                <section>
				                        <h2>Exemple</h2>
				                        <p>
				                         On va utiliser une addresse de base <b>api.foo.bar.com</b>
				                        <br/>
				                         Pour accéder au utilisateur, on va utiliser l'URI <b>users</b>,
				                         donc pour créer, lister, mettre à jour, supprimer des utilisateurs,
				                         on utilisera l'adresse <b>http://api.foo.bar.com/users</b>
				                        </p> 
				                </section>
				                
				                <section>
					             <h2>Utilisation des actions</h2>
					             <table>
					             <tr>
					              <td></td><td>GET</td><td>PUT</td><td>POST</td><td>DELETE</td>
					             </tr><tr>
					              <td>/users/</td><td>liste les utilisateurs</td><td>remplace les utilisateurs</td><td>crée un nouvel utilisateur</td><td>détruit les utilisateurs</td>
					             </tr><tr>
                                     <td>/users/bob</td><td>récupère les propriétés d'un utilisateur</td><td>met à jour un utilisateur</td><td></td><td>supprime un utilisateur</td>
					             </tr>
					             </table>
				                </section>

				               <section>
				                 <h2>Côté Client: JavaScript</h2>
				               </section>


                <section>
                    <h2>JSON</h2>
                </section>
                <section>
                    <h2>JSON ?</h2>
                    <blockquote cite="https://en.wikipedia.org/wiki/JSON">
                        &ldquo;JSON (JavaScript Object Notation) is an open-standard format that uses human-readable text to transmit data objects consisting of attribute–value pairs. It is the most common data format used for asynchronous browser/server communication.&rdquo;
                    </blockquote>
                    <p align="right">
                        source: Wikipedia.org - <a href="https://en.wikipedia.org/wiki/JSON">JSON</a>
                    </p>
                </section>
                <section>
                    <h2>JSON ?</h2>
                    <blockquote cite="https://en.wikipedia.org/wiki/Document_Object_Model">
                        &ldquo;JSON (Notation objet JavaScript) est un format standard ouvert qui utilise un texte lisible par un humain pour transmettre des données objets sous forme de couples attribut/valeur. C'est le format d'échange de données le plus couramment utilisé pour la communication asynchrone entre browser et serveur.&rdquo;
                    </blockquote>
                    <p align="right">
                        source : Wikipedia.org - <a href="https://en.wikipedia.org/wiki/JSON">JSON</a>
                    </p>
                </section>

                <section>
                    <h2>Notation JSON</h2>
                    <p>
                      Format d'échange <bold>textuel</bold> qui utilise un sous ensemble de la notation
                      sur les objets et les tableaux JavaScript
                    </p>
                    <small><textarea autojslog="js-json1" rows="11" cols="40">
let aquarium = `{
	"name": "my-aquarium",
	"fishs": [{
		"name": "guppi",
	}, {
		"name": "sushi",
		"price": 20
	}]
  }`;
  console.log(typeof aquarium);
                                        </textarea></small>
                    <div><small>
                        <div id="js-json1" class="autojslog"></div>
                    </small></div>
                    <div><small>
                        seuls les types primitifs sont suppportés,
                        boolean, number, string, array &amp; object.
                      <br/>
                        Les noms des propriétés apparaissent entre " " !
                    </small></div>
                </section>

                <section>
                <h2>JSON.stringify</h2>
                <p>
                  Permet d'encoder des objets/tableaux JavaScript au format textuel JSON
                </p>
                <small><textarea autojslog="js-json-stringify" rows="11" cols="40">
let aquarium = {
	name: "my-aquarium",
	fishs: [{
		name: "guppi",
	}, {
		name: "sushi",
		price: 20
	}]
  };
console.log(JSON.stringify(aquarium));
                                        </textarea></small>
                <small>
                    <div id="js-json-stringify" class="autojslog"></div>
                </small>
                </section>

                <section>
                    <h2>JSON.parse</h2>
                    <p>
                      Permet de décoder en JavaScript une chaine de caractères comme un objet JSON
                    </p>
                    <small><textarea autojslog="js-json2" rows="8" cols="55">
var array = JSON.parse('[1, 2, 4, true]');
console.log(array);

var object = JSON.parse('{ "name": "john", "age": 26 }');
console.log(object);

JSON.parse('{ name: "john", age: 26 }');  // oops
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-json2" class="autojslog"></div>
                    </small>
                </section>

                <section>
                    <h2>Asynchronous Javascript And XML</h2>
                </section>
                <section>
                    <h2>AJAX ?</h2>
                    <blockquote cite="https://en.wikipedia.org/wiki/Ajax_%28programming%29">
                        &ldquo;Ajax (also AJAX; short for asynchronous JavaScript and XML) is a set of web development techniques using many web technologies on the client-side to create asynchronous Web applications.&rdquo;
                    </blockquote>
                    <p align="right">
                        source: Wikipedia.org - <a href="https://en.wikipedia.org/wiki/Ajax_%28programming%29">AJAX</a>
                    </p>
                </section>
                <section>
                    <h2>AJAX ?</h2>
                    <blockquote cite="https://en.wikipedia.org/wiki/Ajax_%28programming%29">
                        &ldquo;Ajax (aussi AJAX; acronyme pour JavaScript asynchrone et XML) est un ensemble de techniques de développement web utilisant plusieurs technologies web côté client dans le but de créer des applications Web asynchrones.&rdquo;
                    </blockquote>
                    <p align="right">
                        source : Wikipedia.org - <a href="https://en.wikipedia.org/wiki/Ajax_%28programming%29">AJAX</a>
                    </p>
                </section>

                <section>
                    <h2>AJAX ou AJAJ</h2>
                    <p>
                        AJAX, permet en Javascript de faire des requêtes à un serveur en enregistrant une fonction
                        qui sera exécutée plus tard, lorsque les données du serveur seront disponibles.
                    </p>
                    <p>
                        Le fait de faire le traitement plus tard lorsque les données seront présentes est appelé
                        traitement <strong>asynchrone</strong>
                    </p>
                    <p>
                        Dans la réalité, on utilise plutôt JSON que XML comme format de transport,
                        mais on garde le nom AJAX (au lieu de AJAJ).
                    </p>
                </section>
                <section>
                    <h2>XML ou JSON ?</h2>
                    <p>
                        JSON est non structuré et non validable facilement donc
                        il est utilisé pour les transferts de petites données (en kilo)
                    </p>
                    <p>
                        XML est plus lourd mais structuré et validable,
                        il est utilisé pour le transfert de données plus importantes (en méga)
                    </p>
                </section>

                <section>
                    <h2>async/await et fetch</h2>
                </section>
                <section>
				    <h2>Fetch</h2>
					<p>
					  <b>fetch(uri, option?)</b> effectue un appel HTTP asynchrone.
                    <br/>
                      option est un objet qui indique la méthode HTTP utilisée
                      (GET, PUT, POST, DELETE).
                    </p>
                    <pre><code class="js" data-trim>
let response = await fetch("/api/users", { method: "???" });
                    </code></pre>
                    <p><small>
                      <bold>await</bold> indique que le moteur JS va faire
                      autre chose avant de revenir lorsque l'appel est effectué
                    </small></p>
				</section>

                <section>
                    <h2>Fetch GET</h2>
                    <p>
                      Fait un appel asynchrone à une API REST
                     <br/>
                      avec la méthode GET
                    </p>
                    <pre><code class="js" data-trim>
let response = await fetch("api/users", { method: "GET" })
if (!response.ok) {
  throw new Error(response.statusText);
}
                    </code></pre>
                    <p><small>
                      fetch renvoie une réponse même si la réponse est Not Found,
                     <br/>
                      il faut checker si la réponse est ok.
                    </small></p>
                </section>

                <section>
                    <h2>Fetch PUT</h2>
                    <p>
                      Pour un PUT, on veut envoyer du JSON.
                      On doit indiquer le Content-Type correspondant à JSON dans le header.
                      On envoie le JSON sous forme de string dans le body.
                    </p>
                    <pre><code class="js" data-trim>
let object = ...
let response = await fetch("/api/users", {
    method: "PUT",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify(object)
});
if (!response.ok) {
  throw new Error(response.statusText);
}
                    </code></pre>
                    <p><small>
                     Attention à ne pas oublier l'appel à JSON.stringify() !
                    </small></p>
                </section>

                <section>
                    <h2>Fetch POST</h2>
                    <p>
                        Un POST marche comme PUT
                    </p>
                    <pre><code class="js" data-trim>
let object = ...
let response = await fetch("/api/users", {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify(object)
});
if (!response.ok) {
  throw new Error(response.statusText);
}
                    </code></pre>
                </section>

                <section>
                    <h2>DELETE</h2>
                    <p>
                      On peut spécifier l'id que l'on veut supprimer dans l'URI
                    </p>
                    <pre><code class="js" data-trim>
let object = ...
let response = await fetch("/api/users/id", {
    method: "DELETE"
});
if (!response.ok) {
  throw new Error(response.statusText);
}
                    </code></pre>
                </section>

                <section>
                    <h2>Recevoir du JSON</h2>
                    <p>
                      Le parsing de JSON (le retour de response.json()) est aussi asynchrone,
                      il faut un autre await !
                    </p>
                    <pre><code class="js" data-trim>
let response = await fetch("images/js-object/demo.json");  // GET
if (!response.ok) {
  throw new Error(response.statusText);
}
let json = await response.json();
                     </textarea></small>
                    </code></pre>
                </section>


                <section>
                    <h2>async/await</h2>
                </section>

                <section>
                    <h2>Fonction Async</h2>
                    <p>
                      Si l'on fait un <bold>await</bold> dans une fonction,
                      celle-ci doit être déclarée <bold>async</bold>.
                    </p>
                    <small><textarea autojslog="js-async-fun" rows="10" cols="55">
async function fetchDemo() {
  let response = await fetch("images/js-object/demo.json");
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  let result = await response.json();
  console.log(result);
}
fetchDemo();
                     </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-async-fun" class="autojslog"></div>
                    </small>
                </section>

                <section>
                    <h2>Fonction flèche et Async</h2>
                    <p>
                      Même chose pour les fonctions flèches.
                    </p>
                    <small><textarea autojslog="js-async-arrow" rows="10" cols="55">
let fetchDemo = async () => {
  let response = await fetch("images/js-object/demo2.json");
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  let result = await response.json();
  console.log(result);
}
fetchDemo();
                     </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-async-arrow" class="autojslog"></div>
                    </small>
                </section>

                <section>
                    <h2>Await sans async</h2>
                    <p>
                        await ne marche qu'à l'intérieur d'une fonction async
                    </p>
                    <small><textarea autojslog="js-await-without-async" rows="5" cols="45">
function noAsync() {
  let response =
      await fetch("images/js-object/demo.json");
}
                     </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-await-without-async" class="autojslog"></div>
                    </small>
                    <p></p>
                </section>



                <section>
                    <h2>Les Promesses (Promise)</h2>
                </section>

                <section>
                    <h2>Promise</h2>
                    <p>
                      C'est l'objet qui est utilisé en interne par async/await
                     <br/>
                      Il représente la promesse d'une valeur future
                    </p>
                    <small><textarea autojslog="js-promise" rows="6" cols="45">
async function foo() {
  return 3;
}
console.log(typeof foo());
console.log(foo() instanceof Promise);
                    </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-promise" class="autojslog"></div>
                    </small>
                    <p></p>
                </section>

                <section>
                    <h2>Promise.then(function)</h2>
                    <p>
                      Permet d'accéder à la valeur de la promesse
                      une fois celle-ci connue
                    </p>
                    <small><textarea autojslog="js-promise-then" rows="6" cols="45">
async function foo() {
  return 3;
}
let promise = foo();
promise.then(value => console.log(value));
                    </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-promise-then" class="autojslog"></div>
                    </small>
                    <p></p>
                </section>

                <section>
                    <h2>Promise.catch(function)</h2>
                    <p>
                        Permet d'accéder l'erreur de la promesse
                        une fois celle-ci connue
                    </p>
                    <small><textarea autojslog="js-promise-catch" rows="9" cols="45">
async function divide(divisor) {
  if (divisor === 0) {
    throw new Error("oops");
  }
  return 42 / divisor;
}
let promise = divide(0);
promise.catch(err => console.log(err.message));
                    </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-promise-catch" class="autojslog"></div>
                    </small>
                    <p></p>
                </section>

                <section>
                    <h2>Async fonction</h2>
                    <p>
                        Async met la valeur de retour de la fonction dans une promesse
                        si ce n'est pas déjà le cas
                    </p>
                    <div style="float: left;">
                        <small>JavaScript 2017</small><br/>
                        <small><textarea autojslog="js-async-fun-a" rows="7" cols="38">
async function foo() {
  return 3;
}
foo()
  .then(value => console.log(value));
                    </textarea></small>
                        <p></p>
                        <small>
                            <div id="js-async-fun-a" class="autojslog"></div>
                        </small>
                    </div><div>
                    <small>JavaScript 2015</small><br/>
                    <small><textarea autojslog="js-async-fun-b" rows="7" cols="38">
function foo() {
  return Promise.resolve(3);
}
foo()
  .then(value => console.log(value));
                </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-async-fun-b" class="autojslog"></div>
                    </small>
                </div>
                    <p>
                        <small></small>
                    </p>
                </section>

                <section>
                    <h2>Async fonction (2)</h2>
                    <p>
                        Async met les exceptions qui sortent de la fonction dans une promesse
                    </p>
                    <div style="float: left;">
                        <small>JavaScript 2017</small><br/>
                        <small><textarea autojslog="js-async-error-a" rows="7" cols="38">
async function boom() {
  throw new Error("oops");
}
boom()
  .catch(err => console.log(err.message));
                    </textarea></small>
                        <p></p>
                        <small>
                            <div id="js-async-error-a" class="autojslog"></div>
                        </small>
                    </div><div>
                    <small>JavaScript 2015</small><br/>
                    <small><textarea autojslog="js-async-error-b" rows="7" cols="38">
function boom() {
  return Promise.reject(new Error("oops"));
}
boom()
  .catch(err => console.log(err.message));
                </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-async-error-b" class="autojslog"></div>
                    </small>
                </div>
                    <p>
                        <small></small>
                    </p>
                </section>

                <!-- section>
                    <h2>Async Fetch + JSON</h2>
                    <p>
                        Comme response.json() renvoie une promesse, il marche aussi avec await
                    </p>
                    <small><textarea autojslog="js6-fetch-async-json" rows="13" cols="55">
async function callAPI() {
  let response = await fetch("images/js-object/demo.json");
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  return response.json();  // pas de await
}

(async () => {
  let object = await callAPI();
  console.log(object);
 })();
                     </textarea></small>
                    <p></p>
                    <small>
                        <div id="js6-fetch-async-json" class="autojslog"></div>
                    </small>
                    <p>
                        <small>comme cela pas de callback dans les callbacks</small>
                    </p>
                </section -->

                <section>
                    <h2>Fetch renvoie une promesse</h2>
                    <p>
                      Avant 2017, on utilisait fetch() avec l'API des promesses
                    </p>
                    <small><div class="bad-container"><textarea autojslog="js6-fetch" rows="9" cols="57">
fetch("images/js-object/demo.json", { method: "GET" })
  .then(response => {
     if (!response.ok) {
       throw new Error(response.statusText);
     }
     console.log(response.status);
   })
  .catch(err => console.log(err.message));
                    </textarea><div class="bad-image"></div></div></small>
                    <p></p>
                    <small>
                        <div id="js6-fetch" class="autojslog"></div>
                    </small>
                    <p><small>
                        <b>then()</b> et <b>catch()</b> permettent d'installer des closures
                        qui seront appelées si la valeur est résolue ou s'il y a une erreur
                    </small></p>
                </section>

                <section>
                    <h2>Await une promesse</h2>
                    <p>
                        await attend une promesse et met le code qui suit dans
                        un <b>then</b> en tant que closure et re-propage les
                        exceptions
                    </p>
                    <div style="float: left;">
                        <small>JavaScript 2017</small><br/>
                        <small><textarea autojslog="js-await-a" rows="12" cols="43">
async function foo() {
  let response =
      await fetch("images/js-object/demo.json");
  if (response.ok) {
    throw new Error(response.status);
  }
  // my code here !
}
foo();
                                        </textarea></small>
                        <p></p>
                        <small>
                            <div id="js-await-a" class="autojslog"></div>
                        </small>
                    </div><div>
                    <small>JavaScript 2015</small><br/>
                    <small><textarea autojslog="js-await-b" rows="12" cols="37">
function foo() {
  let promise =
      fetch("images/js-object/demo.json");
  promise.then(response => {
    if (response.ok) {
      throw new Error(response.status);
    }
    // my code here !
  });
}
foo();
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js-await-b" class="autojslog"></div>
                    </small>
                </div>
                </section>


                <section>
                    <h2>Fetch et Promise.all()</h2>
                </section>
                <section>
                    <h2>await et performance</h2>
                    <p>
                        await ne permet pas de faire plusieurs requêtes en parallèle
                    </p>
                    <small><div class="bad-container"><textarea autojslog="js6-promise-all-await" rows="13" cols="60">
async function fetchAll() {
  let response1 = await fetch('images/js-object/demo.json');
  let response2 = await fetch('images/js-object/demo2.json');
  if (!response1.ok || !response2.ok) {
    throw new Error(response1.statusText + ' ' + response2.statusText);
  }
  return [await response1.json(), await response2.json()];
}

fetchAll()
  .then(array => array.forEach(o => console.log(o)))
  .catch(err => console.log(err.message));
                                        </textarea><div class="bad-image"></div></div></small>
                    <p></p>
                    <small>
                        <div id="js6-promise-all-await" class="autojslog"></div>
                    </small>
                    <p><small>les fetchs sont fait les uns après les autres !</small></p>
                </section>
                <section>
                    <h2>Promise.all</h2>
                    <p>
                        Calcul en parallèle, le résultat est une promesse
                        contenant le tableau des valeurs
                    </p>
                    <small><textarea autojslog="js6-promise-all" rows="14" cols="60">
async function callAPI(url) {
  let response = await fetch(url);
  if (!response.ok) { throw new Error(response.statusText); }
  return await response.json();
}
async function fetchAll() {
  let [o1, o2] = await Promise.all([
    callAPI('images/js-object/demo.json'),
    callAPI('images/js-object/demo2.json')
  ]);
  console.log(o1, o2);
}
fetchAll();
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js6-promise-all" class="autojslog"></div>
                    </small>
                    <p></p>
                </section>
                <section>
                    <h2>Promise.race</h2>
                    <p>
                      La promesse résultante est calculée dès qu'une des promesses a fini
                    </p>
                    <small><textarea autojslog="js6-promise-race" rows="14" cols="60">
async function callAPI(url) {
  let response = await fetch(url);
  if (!response.ok) { throw new Error(response.statusText); }
  return await response.json();
}
async function fetchAny() {
  let object = await Promise.race([
    callAPI('images/js-object/demo.json'),
    callAPI('images/js-object/demo2.json')
  ]);
  console.log(object);
}
fetchAny();
                                        </textarea></small>
                    <p></p>
                    <small>
                        <div id="js6-promise-race" class="autojslog"></div>
                    </small>
                    <p></p>
                </section>

                <section>
                    <h2>AJAX: ancienne API</h2>
                    <p>
                        Appel Asynchrone en utilisant un <b>HttpXMLRequest</b>
                    </p>
                    <pre><code class="js" data-trim>
let ajax = new XMLHttpRequest();
ajax.onreadystatechange = () => {
  if (ajax.readyState != 4) { return; }
  if(ajax.status != 200) {
     // TODO NOT OK ! (ajax.status)
  } else {
     // TODO OK (ajax.responseText)
  }
};
ajax.open('GET', 'http://api.foo.bar.com/users/bob', true);
ajax.send();
                                </code></pre>
                    <p>
                        <small>fetch() est plus simple ... et mieux</small>
                    </p>
                </section>

				<section>
				                        <h2>Promesse &amp; AJAX à la main</h2>
					                    <p>
                                         <small>
                                             On peut faire en sorte de voir un <b>HttpXMLRequest</b>
                                             comme une promesse
                                         </small>
                                        </p>
                                        <small><textarea autojslog="js6-promise-ajax" rows="19" cols="45">
function ajaxPromise(doc) {
  return new Promise((resolve, reject) => {
    let ajax = new XMLHttpRequest();
    ajax.onreadystatechange = () => {
      if (ajax.readyState != 4) { return; }
      if(ajax.status != 200) {
        reject(new Error("error " + ajax.status));
      } else {
        resolve(ajax.responseText);
      }
    };
    ajax.open("GET", doc, true);
    ajax.send();
  });
}
ajaxPromise("images/js-object/demo.json")
  .then(value => console.log(value))
  .catch(err => console.log(err.message));
                                        </textarea></small>
                                        <p></p>
                                        <small>
                                         <div id="js6-promise-ajax" class="autojslog"></div>
                                        </small>
				</section>


                <section>
                    <h2>Côté Serveur</h2>
                </section>

                <section>
                    <h2>Exemple avec Express.js</h2>
                    <p>
                        express.js est une bibliothèque qui permet de créer des points d'entrée (<b>endpoint</b>)
                        REST en JavaScript.
                        <br/>
                        Elle utilise le "serveur" node.js
                    </p>
                </section>

                <section>
                    <h2>Exemple avec Express.js</h2>
                    <pre><code class="js" data-trim>
let express = require('express');
let app = express();

app.get('/users', (req, res) =&gt; {
  res.send('Hello World!');
});

app.listen(3000);
                                </code></pre>
                    <p><small>
                        On crée un endpoint sur l'URI /users puis on écoute les clients sur le port TCP 3000
                    </small></p>
                </section>

                <section>
                    <h2>Créer un endpoint</h2>
                    <p>
                        on utilise les verbes get, post, put, delete (en minuscules)
                    </p>
                    <pre><code class="js" data-trim>
app.post('/users', (req, res) =&gt; {
  ...
})
                                </code></pre>
                    <pre><code class="js" data-trim>
app.put('/users', (req, res) =&gt; {
  ...
})
                                </code></pre>
                    <pre><code class="js" data-trim>
app.delete('/users', (req, res) =&gt; {
  ...
})
                                </code></pre>
                </section>

                <section>
                    <h2>Extraire des paramètres de l'URI</h2>
                    <p>
                        la propriété <b>params</b> de l'objet requête permet d'obtenir les paramètres
                        nommés extraits de l'URI
                    </p>
                    <pre><code class="js" data-trim>
app.get('/users/:id', (req, res) =&gt; {
  console.log('user id ' + req.params.id);
})
                                </code></pre>
                    <p><small>
                        Les paramètres nommés commencent par ':' dans l'URI
                    </small></p>
                </section>

                <section>
                    <h2>Récupérer les cookies dans la requête</h2>
                    <p>
                        Les cookies sont stockés par le client et envoyés à chaque requête
                    </p>
                    <pre><code class="js" data-trim>
app.get('/users/:id', (req, res) =&gt; {
  console.log(req.cookies);
})
                                </code></pre>
                    <p><small>
                        <b>cookies</b> contient tous les cookies valides pour l'URI
                        <br/>
                        <b>cookies</b> est un objet dont les clés sont les noms des cookies
                    </small></p>
                </section>

                <section>
                    <h2>Code de la réponse</h2>
                    <p>
                        <b>status</b> permet d'indiquer le code HTTP de la réponse
                    </p>
                    <pre><code class="js" data-trim>
app.get('/users/:id', (req, res) =&gt; {
  res.status(404).send('Oops');
})
                                </code></pre>
                    <p>
                        <small><a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a></small>
                    </p>
                </section>

                <section>
                    <h2>Envoyer une réponse (texte)</h2>
                    <p>
                        <b>send</b> permet d'envoyer une réponse textuelle
                    </p>
                    <pre><code class="js" data-trim>
app.get('/users/:id', (req, res) =&gt; {
  res.send('OK !');
})
                                </code></pre>
                    <p><small>
                        Le Content-Length est la longeur de la chaine de caractères
                        <br/>
                        Si le <b>status</b> n'est pas positionné, la valeur est 200
                    </small></p>
                </section>

                <section>
                    <h2>Envoyer une réponse (fichier)</h2>
                    <p>
                        <b>sendFile</b> permet d'envoyer un fichier en réponse
                    </p>
                    <pre><code class="js" data-trim>
app.get('/users/:id', (req, res) =&gt; {
  res.sendFile('/absolute/path/to/ok.png');
})
                                </code></pre>
                    <p><small>
                        Le Content-Type dépend de l'extension
                        <br/>
                        le Content-Length est la taille du fichier.
                    </small></p>
                </section>

                <section>
                    <h2>Envoyer une réponse (JSON)</h2>
                    <p>
                        <b>json</b> permet d'envoyer une réponse au format JSON
                    </p>
                    <pre><code class="js" data-trim>
app.get('/users/:id', (req, res) =&gt; {
  let id = req.params.id;
  res.json('{ user: ' + id + ' }');
})
                                </code></pre>
                    <p><small>
                        Le Content-Type est <b>application/json</b>
                    </small></p>
                </section>

                <section>
                    <h2>Envoyer des entêtes de réponse</h2>
                    <p>
                        Sur l'objet réponse, <b>set</b> et <b>append</b> permettent d'ajouter
                        des entêtes de réponse.
                    </p>
                    <pre><code class="js" data-trim>
app.get('/users/:id', (req, res) =&gt; {
  res.set('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
})
                                </code></pre>
                    <p><small>
                        <b>HttpOnly</b> veut dire pas dans les requêtes AJAX !
                    </small></p>
                </section>

                <section>
                    <h2>Content-Type</h2>
                    <p>
                        <b>type</b> permet d'indiquer le Content-Type.
                    </p>
                    <pre><code class="js" data-trim>
app.get('/users/:id', (req, res) =&gt; {
  res.type('text/html').send('<html><body>Ok</body></html>');
})
                                </code></pre>
                </section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                                        { src: 'plugin/autoeval/autoeval.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
